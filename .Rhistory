summary(McapCpGHighModel) #Running the full model leads to a convergence issue. The model is likely overparametrized.
McapCpGPercentsHigh <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C"), times = 3),
"replicate" = rep(seq(1:3), times = 3),
"highMeth" = McapCpGTypePercents[,1] / 100) #Remove moderate and low methylation information and add sequencing metadata
McapCpGPercentsHigh <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C"), times = 3)),
McapCpGPercentsHigh <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(seq(1:3), times = 3),
"highMeth" = McapCpGTypePercents[,1] / 100) #Remove moderate and low methylation information and add sequencing metadata
head(McapCpGPercentsHigh) #Confirm dataframe creation
McapCpGPercentsMod <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(seq(1:3), times = 3),
"modMeth" = McapCpGTypePercents[,2] / 100) #Remove high and low methylation information and add sequencing metadata
head(McapCpGPercentsMod) #Confirm dataframe creation
McapCpGPercentsLow <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(seq(1:3), times = 3),
"lowMeth" = McapCpGTypePercents[,3] / 100) #Remove moderate and low methylation information and add sequencing metadata
head(McapCpGPercentsLow) #Confirm dataframe creation
McapCpGHighModel <- glmmTMB(highMeth ~ seqMethod + replicate,
family = beta_family(link = "logit"),
data = McapCpGPercentsHigh) #Run the full model (all genomic locations) using a beta distribution and a logit link
summary(McapCpGHighModel) #Running the full model leads to a convergence issue. The model is likely overparametrized.
McapCpGHighModel <- glmmTMB(highMeth ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapCpGPercentsHigh) #Run the full model (all genomic locations) using a beta distribution and a logit link
summary(McapCpGHighModel) #Running the full model leads to a convergence issue. The model is likely overparametrized.
McapCpGPercentsMod <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(seq(1:3), times = 3),
"modMeth" = McapCpGTypePercents[,2] / 100) #Remove high and low methylation information and add sequencing metadata
head(McapCpGPercentsMod) #Confirm dataframe creation
McapCpGModModel <- glmmTMB(modMeth ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapCpGPercentsHigh) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
McapCpGModModel <- glmmTMB(modMeth ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapCpGPercentsMod) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapCpGModModel) #Look at model output
McapCpGPercentsLow <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(seq(1:3), times = 3),
"lowMeth" = McapCpGTypePercents[,3] / 100) #Remove moderate and low methylation information and add sequencing metadata
head(McapCpGPercentsLow) #Confirm dataframe creation
McapCpGLowModel <- glmmTMB(lowMeth ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapCpGPercentsLow) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapCpGLowModel) #Look at model output
PactCpGPercentsHigh <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(seq(1:3), times = 3),
"highMeth" = PactCpGTypePercents[,1] / 100) #Remove moderate and low methylation information and add sequencing metadata. A = WGBS, B = RRBS, C = MBD-BS. Needed to alphabetize so RRBS and MBD-BS are compared to WGBS (model default is alphabetized)
head(PactCpGPercentsHigh) #Confirm dataframe creation
PactCpGHighModel <- glmmTMB(highMeth ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = PactCpGPercentsHigh) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(PactCpGHighModel) #Look at model output
PactCpGPercentsMod <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(seq(1:3), times = 3),
"modMeth" = PactCpGTypePercents[,2] / 100) #Remove high and low methylation information and add sequencing metadata
head(PactCpGPercentsMod) #Confirm dataframe creation
PactCpGModModel <- glmmTMB(modMeth ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = PactCpGPercentsMod) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(PactCpGModModel) #Look at model output
PactCpGPercentsLow <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(seq(1:3), times = 3),
"lowMeth" = PactCpGTypePercents[,3] / 100) #Remove moderate and low methylation information and add sequencing metadata
head(PactCpGPercentsLow) #Confirm dataframe creation
PactCpGLowModel <- glmmTMB(lowMeth ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = PactCpGPercentsLow) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(PactCpGLowModel) #Look at model output
head(McapFeatureOverlapsPercents)
head(t(McapFeatureOverlapsPercents[,seq(5, 37, 4)] / 100))
head(data.frame(t(McapFeatureOverlapsPercents[,seq(5, 37, 4)] / 100)))
McapFeatureOverlapsGLMData <- cbind("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(seq(1:3), times = 3),
data.frame(t(McapFeatureOverlapsPercents[,seq(5, 37, 4)] / 100))) #Create master dataframe for GLM
head(McapFeatureOverlapsGLMData) #Confirm dataframe creation
McapCDSModel <- glmmTMB(CDS ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapFeatureOverlapsGLMData) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapCDSModel) #Look at model output
McapIntronsModel <- glmmTMB(Introns ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapFeatureOverlapsGLMData) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapIntronsModel) #Look at model output
McapUpstreamFlanksModel <- glmmTMB(Upstream.Flanks ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapFeatureOverlapsGLMData) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapUpstreamFlanksModel) #Look at model output
McapDownstreamFlanksModel <- glmmTMB(Downstream.Flanks ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapFeatureOverlapsGLMData) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapDownstreamFlanksModel) #Look at model output
McapIntergenicModel <- glmmTMB(Intergenic ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapFeatureOverlapsGLMData) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapIntergenicModel) #Look at model output
length(McapFeatureOverlaps[1,])
for (i in 1:length(McapFeatureOverlaps[1,])) {
McapFeatureOverlapsPercents[i,] <- (McapFeatureOverlapsPercents[i,] / McapFeatureOverlapsPercents[1,]) * 100
}
head(McapFeatureOverlapsPercents) #Check calculations
McapFeatureOverlapsPercents <- McapFeatureOverlaps[-c(1,4),] #Duplicate dataframe but remove gene and total flank rows
for (i in 1:length(McapFeatureOverlaps[1,])) {
McapFeatureOverlapsPercents[i,] <- (McapFeatureOverlapsPercents[i,] / McapFeatureOverlapsPercents[i,1]) * 100
} #Divide every entry by sum of the column and multiply by 100 to get percentages. Do not include gene information
head(McapFeatureOverlapsPercents) #Check calculations
McapCpGPercentsWGRR <- vegdist(McapCpGPercentsTrans[c(1:3, 4:6),], "euclidean") #Subset WGBS and RRBS data and calculate dissimilarity matrix
McapCpGPercentsWGRRANOSIM <- adonis(McapCpGPercentsWGRR, grouping = ANOSIMReplicates[1:6]) #Conduct pairwise ANOSIM for WGBS and RRBS data. Only use sequencing method metadata for these samples
McapCpGPercentsWGRRANOSIM <- adonis(McapCpGPercentsWGRR) #Conduct pairwise ANOSIM for WGBS and RRBS data. Only use sequencing method metadata for these samples
McapCpGPercentsWGRRANOSIM <- adonis(McapCpGPercentsWGRR ~ ANOSIMReplicates[1:6]) #Conduct pairwise ANOSIM for WGBS and RRBS data. Only use sequencing method metadata for these samples
McapCpGPercentsWGRRANOSIM$statistic
McapCpGPercentsWGRRANOSIM
McapCpGPercentsWGRRANOSIM <- anosim(McapCpGPercentsWGRR, grouping = ANOSIMReplicates[1:6]) #Conduct pairwise ANOSIM for WGBS and RRBS data. Only use sequencing method metadata for these samples
McapCpGPercentsWGRRANOSIM
summary(McapCpGPercentsWGRRANOSIM)
McapCpGPercentsWGRRTest <- adonis(McapCpGPercentsWGRR, grouping = ANOSIMReplicates[1:6]) #Conduct pairwise ANOSIM for WGBS and RRBS data. Only use sequencing method metadata for these samples
McapCpGPercentsWGRRTest <- adonis(McapCpGPercentsWGRR ~ ANOSIMReplicates[1:6]) #Conduct pairwise ANOSIM for WGBS and RRBS data. Only use sequencing method metadata for these samples
McapCpGPercentsWGRRTest
McapCpGPercentsTest <- adonis(dissimMcapCpGPercentsTrans ~ ANOSIMReplicates) #Conduct perMANOVA by method
McapCpGPercentsTest
dispersion.model=betadisper(dissimMcapCpGPercentsTrans,group=ANOSIMReplicates,type='centroid')
summary(dispersion.model)
dispersion.model
plot(dispersion.model,label=T)
anova(dispersion.model)
McapCpGPercentsHigh <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(seq(1:3), times = 3),
"highMeth" = McapCpGTypePercents[,1] / 100) #Remove moderate and low methylation information and add sequencing metadata. A = WGBS, B = RRBS, C = MBD-BS. Needed to alphabetize so RRBS and MBD-BS are compared to WGBS (model default is alphabetized)
head(McapCpGPercentsHigh) #Confirm dataframe creation
McapCpGHighModel <- glmmTMB(highMeth ~ seqMethod + replicate,
family = beta_family(link = "logit"),
data = McapCpGPercentsHigh) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapCpGHighModel) #Look at model output
McapCpGPercentsHigh <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"highMeth" = McapCpGTypePercents[,1] / 100) #Remove moderate and low methylation information and add sequencing metadata. A = WGBS, B = RRBS, C = MBD-BS. Needed to alphabetize so RRBS and MBD-BS are compared to WGBS (model default is alphabetized)
head(McapCpGPercentsHigh) #Confirm dataframe creation
McapCpGHighModel <- glmmTMB(highMeth ~ seqMethod + replicate,
family = beta_family(link = "logit"),
data = McapCpGPercentsHigh) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapCpGHighModel) #Look at model output
McapCpGPercentsHigh <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(c("1", "2", "3"), times = 3),
"highMeth" = McapCpGTypePercents[,1] / 100) #Remove moderate and low methylation information and add sequencing metadata. A = WGBS, B = RRBS, C = MBD-BS. Needed to alphabetize so RRBS and MBD-BS are compared to WGBS (model default is alphabetized)
head(McapCpGPercentsHigh) #Confirm dataframe creation
McapCpGHighModel <- glmmTMB(highMeth ~ seqMethod + replicate,
family = beta_family(link = "logit"),
data = McapCpGPercentsHigh) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapCpGHighModel) #Look at model output
McapCpGHighModel <- glmmTMB(highMeth ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapCpGPercentsHigh) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapCpGHighModel) #Look at model output
McapFeatureOverlapsPercents <- McapFeatureOverlaps[-c(1,4),] #Duplicate dataframe but remove gene and total flank rows
for (i in 1:length(McapFeatureOverlaps)) {
McapFeatureOverlapsPercents[,i] <- (McapFeatureOverlapsPercents[,i] / McapFeatureOverlapsPercents[,i]) * 100
} #Divide every entry by sum of the column and multiply by 100 to get percentages. Do not include gene information
head(McapFeatureOverlapsPercents) #Check calculations
McapFeatureOverlapsPercents <- McapFeatureOverlaps[-c(1,4),] #Duplicate dataframe but remove gene and total flank rows
for (i in 1:length(McapFeatureOverlaps)) {
McapFeatureOverlapsPercents[,i] <- (McapFeatureOverlapsPercents[,i] / McapFeatureOverlapsPercents[,i]) * 100
} #Divide every entry by sum of the column and multiply by 100 to get percentages. Do not include gene information
head(McapFeatureOverlapsPercents) #Check calculations
McapFeatureOverlapsPercents <- McapFeatureOverlaps[-c(1,4),] #Duplicate dataframe but remove gene and total flank rows
McapFeatureOverlapsPercents <- McapFeatureOverlaps[-c(1,4),] #Duplicate dataframe but remove gene and total flank rows
for (i in 1:length(McapFeatureOverlaps)) {
McapFeatureOverlapsPercents[,i] <- ((McapFeatureOverlapsPercents[,i] / sum(McapFeatureOverlapsPercents[,i]))) * 100
} #Divide every entry by sum of the column and multiply by 100 to get percentages. Do not include gene information
head(McapFeatureOverlapsPercents) #Check calculations
McapCpGPercentsPCoA <- cmdscale(McapCpGPercentsTrans, eig = TRUE, add = TRUE) #Perform the PCoA. Include eigenvalues for each PC, and add a constant so default eigenvalues are non-negative.
dissimMcapCpGPercentsTrans <- vegdist(McapCpGPercentsTrans, "euclidean") #Calculate euclidean dissimilarity matrix
dissimMcapCpGPercentsTrans <- vegdist(McapCpGPercentsTrans, "euclidean") #Calculate euclidean dissimilarity matrix
McapCpGPercentsPCoA <- cmdscale(dissimMcapCpGPercentsTrans, eig = TRUE, add = TRUE) #Perform the PCoA. Include eigenvalues for each PC, and add a constant so default eigenvalues are non-negative.
McapCpGPercentsPCoA <- cmdscale(dissimMcapCpGPercentsTrans, eig = TRUE, add = TRUE) #Perform the PCoA. Include eigenvalues for each PC, and add a constant so default eigenvalues are non-negative.
McapCpGPercentsPCoA$points #View PC scores
McapCpGPercentsPCoA$eig #View eigenvalues
McapCpGPercentsPCoA$eig #View eigenvalues
McapCpGPercentsPCoA <- cmdscale(dissimMcapCpGPercentsTrans, eig = TRUE, add = TRUE) #Perform the PCoA. Include eigenvalues for each PC, and add a constant so default eigenvalues are non-negative.
McapCpGPercentsPCoA$points #View PC scores
McapCpGPercentsPCoA$eig #View eigenvalues
(McapCpGPercentsPCoA$eig / sum(McapCpGPercentsPCoA$eig)) * 100 #Calculate percent variation explained by each PC
plot(McapCpGPercentsPCoA$eig/sum(McapCpGPercentsPCoA)*100,
type = "b",lwd = 2,col = "blue",
xlab = "Principal Component from PCoA", ylab = "% variation explained", main = "% variation explained by PCoA (blue) vs. random expectation (red)")
plot(McapCpGPercentsPCoA$eig/sum(McapCpGPercentsPCoA)*100, type = "b",lwd = 2,col = "blue", xlab = "Principal Component from PCoA", ylab = "% variation explained", main = "% variation explained by PCoA (blue) vs. random expectation (red)")
plot(McapCpGPercentsPCoA$eig/sum(McapCpGPercentsPCoA)*100, type = "b",lwd = 2,col = "blue", xlab = "Principal Component from PCoA", ylab = "% variation explained", main = "% variation explained by PCoA (blue) vs. random expectation (red)")
plot(McapCpGPercentsPCoA$eig[1:9/sum(McapCpGPercentsPCoA)*100, type = "b",lwd = 2,col = "blue", xlab = "Principal Component from PCoA", ylab = "% variation explained", main = "% variation explained by PCoA (blue) vs. random expectation (red)")
plot(McapCpGPercentsPCoA$eig[1:9]/sum(McapCpGPercentsPCoA)*100, type = "b",lwd = 2,col = "blue", xlab = "Principal Component from PCoA", ylab = "% variation explained", main = "% variation explained by PCoA (blue) vs. random expectation (red)")
plot(McapCpGPercentsPCoA$eig/sum(McapCpGPercentsPCoA$eig)*100, type = "b",lwd = 2,col = "blue", xlab = "Principal Component from PCoA", ylab = "% variation explained", main = "% variation explained by PCoA (blue) vs. random expectation (red)")
lines(bstick(35)*100,type="b",lwd=2,col="red") #Compare eigenvalues to expectations according to the broken stick model
ordiplot(McapCpGPercentsPCoA, choices = c(1,2), type = "text", display = "sites", xlab = "PC 1 (83.1%)", ylab = "PC 2 (16.9%)") #Plot basic PCoA
vec.McapCpGPercentsPCoA <- envfit(scores(McapCpGPercentsPCoA), McapCpGPercentsTrans, perm = 1000) #Extract PCs to calculate PC loadings (variable weights)
vec.McapCpGPercentsPCoA
ordiplot(McapCpGPercentsPCoA, choices = c(1,2), type = "text", display = "sites", xlab = "PC 1 (83.1%)", ylab = "PC 2 (16.9%)") #Plot basic PCoA
plot(vec.McapCpGPercentsPCoA, p.max = 0.05, col = 'blue') #Plot loadings that are significant at the 0.05 level
McapCpGPercentsTest <- adonis(dissimMcapCpGPercentsTrans ~ sampleInformation) #Conduct perMANOVA by method
sampleInformation <- c(rep("WGBS", times = 3),
rep("RRBS", times = 3),
rep("MBDBS", times = 3)) #Create a vector with grouping information
McapCpGPercentsTest <- adonis(dissimMcapCpGPercentsTrans ~ sampleInformation) #Conduct perMANOVA by method
McapCpGPercentsTest
dispersion.model=betadisper(dissimMcapCpGPercentsTrans,group=sampleInformation,type='centroid')
anova(dispersion.model) #Variance is the same across all groups. Significance in perMANOVA due to centroid differences, not variance
disp.McapCpGPercentsTrans <- betadisper(dissimMcapCpGPercentsTrans,group=sampleInformation,type='centroid') #Run a beta dispersion model to assess if significant differences are due to differences in group centroid or variance
anova(disp.McapCpGPercentsTrans) #Variance is the same across all groups. Significance in perMANOVA due to centroid differences, not variance
plot(disp.McapCpGPercentsTrans, label=T)
ordiplot(McapCpGPercentsPCoA, choices = c(1,2), type = "text", display = "sites", xlab = "PC 1 (83.1%)", ylab = "PC 2 (16.9%)") #Plot basic PCoA
plot(vec.McapCpGPercentsPCoA, p.max = 0.05, col = 'blue') #Plot loadings that are significant at the 0.05 level
ordiplot(McapCpGPercentsPCoA, choices = c(1,2), type = "text", display = "sites", xlab = "PC 1 (83.1%)", ylab = "PC 2 (16.9%)") #Plot basic PCoA
plot(vec.McapCpGPercentsPCoA, p.max = 0.05, col = "grey80") #Plot loadings that are significant at the 0.05 level
ordiplot(McapCpGPercentsPCoA, choices = c(1,2), type = "text", display = "sites", xlab = "PC 1 (83.1%)", ylab = "PC 2 (16.9%)") #Plot basic PCoA
plot(vec.McapCpGPercentsPCoA, p.max = 0.05, col = "grey20") #Plot loadings that are significant at the 0.05 level
ordiplot(McapCpGPercentsPCoA, choices = c(1,2), type = "text", display = "sites", xlab = "PC 1 (83.1%)", ylab = "PC 2 (16.9%)") #Plot basic PCoA
plot(vec.McapCpGPercentsPCoA, p.max = 0.05, col = "black") #Plot loadings that are significant at the 0.05 level
ordiplot(McapCpGPercentsPCoA, choices = c(1,2), type = "text", display = "sites", xlab = "PC 1 (83.1%)", ylab = "PC 2 (16.9%)") #Plot basic PCoA
plot(vec.McapCpGPercentsPCoA, p.max = 0.05, col = "blue") #Plot loadings that are significant at the 0.05 level
McapCpGPercentsWGRR <- vegdist(McapCpGPercentsTrans[c(1:3, 4:6),], "euclidean") #Subset WGBS and RRBS data and calculate dissimilarity matrix
McapCpGPercentsWGRRTest <- adonis(McapCpGPercentsWGRR ~ sampleInformation[1:6]) #Conduct pairwise perMANOVA for WGBS and RRBS data. Only use sequencing method metadata for these samples
McapCpGPercentsWGRRTest
McapCpGPercentsWGMB <- vegdist(McapCpGPercentsTrans[c(1:3, 7:9),], "euclidean") #Subset WGBS and MBD-BS data and calculate dissimilarity matrix
McapCpGPercentsWGMBTest <- anosim(McapCpGPercentsWGMB, grouping = sampleInformation[c(1:3, 7:9)]) #Conduct pairwise ANOSIM for WGBS and MBD-BS data. Only use sequencing method metadata for these samples
McapCpGPercentsWGMBTest
McapCpGPercentsWGMB <- vegdist(McapCpGPercentsTrans[c(1:3, 7:9),], "euclidean") #Subset WGBS and MBD-BS data and calculate dissimilarity matrix
McapCpGPercentsWGMBTest <- adonis(McapCpGPercentsWGMB ~ sampleInformation[c(1:3, 7:9)]) #Conduct pairwise perMANOVA for WGBS and MBD-BS data. Only use sequencing method metadata for these samples
McapCpGPercentsWGMBTest
McapCpGPercentsRRMB <- vegdist(McapCpGPercentsTrans[c(4:9),], "euclidean") #Subset RRBS and MBD-BS data and calculate dissimilarity matrix
McapCpGPercentsRRMB <- vegdist(McapCpGPercentsTrans[c(4:9),], "euclidean") #Subset RRBS and MBD-BS data and calculate dissimilarity matrix
McapCpGPercentsRRMBTest <- adonis(McapCpGPercentsRRMB ~ sampleInformation[c(4:9)]) #Conduct pairwise perMANOVA for WGBS and RRBS data. Only use sequencing method metadata for these samples
McapCpGPercentsRRMBTest
McapCpGPercentsHigh <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(c("1", "2", "3"), times = 3),
"highMeth" = McapCpGTypePercents[,1] / 100) #Remove moderate and low methylation information and add sequencing metadata. A = WGBS, B = RRBS, C = MBD-BS. Needed to alphabetize so RRBS and MBD-BS are compared to WGBS (model default is alphabetized)
head(McapCpGPercentsHigh) #Confirm dataframe creation
McapCpGHighModel <- glmmTMB(highMeth ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapCpGPercentsHigh) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapCpGHighModel) #Look at model output
McapCpGPercentsMod <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(c("1", "2", "3"), times = 3),
"modMeth" = McapCpGTypePercents[,2] / 100) #Remove high and low methylation information and add sequencing metadata
head(McapCpGPercentsMod) #Confirm dataframe creation
McapCpGModModel <- glmmTMB(modMeth ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapCpGPercentsMod) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapCpGModModel) #Look at model output
McapCpGPercentsLow <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(c("1", "2", "3"), times = 3),
"lowMeth" = McapCpGTypePercents[,3] / 100) #Remove moderate and low methylation information and add sequencing metadata
head(McapCpGPercentsLow) #Confirm dataframe creation
McapCpGLowModel <- glmmTMB(lowMeth ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapCpGPercentsLow) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapCpGLowModel) #Look at model output
PactCpGPercentsTrans <- data.frame(clr(PactCpGTypePercents / 100)) #Use centered log-ratio transformation on proportion data
tail(PactCpGPercentsTrans) # Confirm transformation
dissimPactCpGPercentsTrans <- vegdist(PactCpGPercentsTrans, "euclidean") #Calculate euclidean dissimilarity matrix
PactCpGPercentsPCoA <- cmdscale(dissimPactCpGPercentsTrans, eig = TRUE, add = TRUE) #Perform the PCoA. Include eigenvalues for each PC, and add a constant so default eigenvalues are non-negative.
PactCpGPercentsPCoA$points #View PC scores
PactCpGPercentsPCoA$eig #View eigenvalues
(PactCpGPercentsPCoA$eig / sum(PactCpGPercentsPCoA$eig)) * 100 #Calculate percent variation explained by each PC
plot(PactCpGPercentsPCoA$eig/sum(PactCpGPercentsPCoA$eig)*100,
type = "b",lwd = 2,col = "blue",
xlab = "Principal Component from PCoA", ylab = "% variation explained", main = "% variation explained by PCoA (blue) vs. random expectation (red)") #Plot eigenvalues
lines(bstick(35)*100, type = "b",lwd = 2, col = "red") #Compare eigenvalues to expectations according to the broken stick model
vec.PactCpGPercentsPCoA <- envfit(scores(PactCpGPercentsPCoA), PactCpGPercentsTrans, perm = 1000) #Extract PCs to calculate PC loadings (variable weights)
vec.PactCpGPercentsPCoA #Look at statistical results
sampleInformation <- c(rep("WGBS", times = 3),
rep("RRBS", times = 3),
rep("MBDBS", times = 3)) #Create a vector with grouping information
PactCpGPercentsTest <- adonis(dissimPactCpGPercentsTrans ~ sampleInformation) #Conduct perMANOVA by method
PactCpGPercentsTest #Look at test output.
PactCpGPercentsTest <- adonis(dissimPactCpGPercentsTrans ~ sampleInformation) #Conduct perMANOVA by method
PactCpGPercentsTest #Look at test output.
disp.PactCpGPercentsTrans <- betadisper(dissimPactCpGPercentsTrans,group=sampleInformation,type='centroid') #Run a beta dispersion model to assess if significant differences are due to differences in group centroid or variance
anova(disp.PactCpGPercentsTrans) #Variance is the same across all groups. Significance in perMANOVA due to centroid differences, not variance
ordiplot(PactCpGPercentsPCoA, choices = c(1,2), type = "text", display = "sites", xlab = "PC 1 (97.9%)", ylab = "PC 2 (2.1%)") #Plot basic PCoA
plot(vec.PactCpGPercentsPCoA, p.max = 0.05, col = "blue") #Plot loadings that are significant at the 0.05 level
PactCpGPercentsWGRR <- vegdist(PactCpGPercentsTrans[c(1:3, 4:6),], "euclidean") #Subset WGBS and RRBS data and calculate dissimilarity matrix
PactCpGPercentsWGRRTest <- adonis(PactCpGPercentsWGRR ~ sampleInformation[1:6]) #Conduct pairwise perMANOVA for WGBS and RRBS data. Only use sequencing method metadata for these samples
PactCpGPercentsWGRRTest
disp.PactCpGPercentsWGRR <- betadisper(PactCpGPercentsWGRR, group = sampleInformation,type='centroid') #Run a beta dispersion model to assess if significant differences are due to differences in group centroid or variance
disp.PactCpGPercentsWGRR <- betadisper(PactCpGPercentsWGRR, group = sampleInformation[1:6], type = 'centroid') #Run a beta dispersion model to assess if significant differences are due to differences in group centroid or variance
anova(disp.PactCpGPercentsWGRR) #Variance is the different between groups. Significance in perMANOVA can be due to centroid and variance differences.
PactCpGPercentsWGMB <- vegdist(PactCpGPercentsTrans[c(1:3, 7:9),], "euclidean") #Subset WGBS and MBD-BS data and calculate dissimilarity matrix
PactCpGPercentsWGMBTest <- adonis(PactCpGPercentsWGMB ~ sampleInformation[c(1:3, 7:9)]) #Conduct pairwise perMANOVA for WGBS and MBD-BS data. Only use sequencing method metadata for these samples
PactCpGPercentsWGMBTest
disp.PactCpGPercentsWGMB <- betadisper(PactCpGPercentsWGMB, group = sampleInformation[c(1:3, 7:9)], type = 'centroid') #Run a beta dispersion model to assess if differences are due to differences in group centroid or variance
anova(disp.PactCpGPercentsWGMB) #Variance is the same between groups.
PactCpGPercentsRRMB <- vegdist(PactCpGPercentsTrans[c(4:9),], "euclidean") #Subset RRBS and MBD-BS data and calculate dissimilarity matrix
PactCpGPercentsRRMBTest <- adonis(PactCpGPercentsRRMB ~ sampleInformation[c(4:9)]) #Conduct pairwise perMANOVA for WGBS and RRBS data. Only use sequencing method metadata for these samples
PactCpGPercentsRRMBTest
disp.PactCpGPercentsRRMB <- betadisper(PactCpGPercentsRRMB, group = sampleInformation[c(4:9)], type = 'centroid') #Run a beta dispersion model to assess if differences are due to differences in group centroid or variance
anova(disp.PactCpGPercentsRRMB) #Variance is significantly different between groups.
PactCpGPercentsHigh <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(c("1", "2", "3"), times = 3),
"highMeth" = PactCpGTypePercents[,1] / 100) #Remove moderate and low methylation information and add sequencing metadata. A = WGBS, B = RRBS, C = MBD-BS. Needed to alphabetize so RRBS and MBD-BS are compared to WGBS (model default is alphabetized)
head(PactCpGPercentsHigh) #Confirm dataframe creation
PactCpGHighModel <- glmmTMB(highMeth ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = PactCpGPercentsHigh) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(PactCpGHighModel) #Look at model output
PactCpGPercentsMod <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(c("1", "2", "3"), times = 3),
"modMeth" = PactCpGTypePercents[,2] / 100) #Remove high and low methylation information and add sequencing metadata
head(PactCpGPercentsMod) #Confirm dataframe creation
PactCpGModModel <- glmmTMB(modMeth ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = PactCpGPercentsMod) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(PactCpGModModel) #Look at model output
PactCpGPercentsLow <- data.frame("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(c("1", "2", "3"), times = 3),
"lowMeth" = PactCpGTypePercents[,3] / 100) #Remove moderate and low methylation information and add sequencing metadata
head(PactCpGPercentsLow) #Confirm dataframe creation
PactCpGLowModel <- glmmTMB(lowMeth ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = PactCpGPercentsLow) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(PactCpGLowModel) #Look at model output
McapCpGPercentsTrans <- data.frame(clr(t(McapFeatureOverlapsPercents[,seq(5, 37, 4)] / 100))) #Use centered log-ratio transformation on proportion data
tail(McapCpGPercentsTrans) # Confirm transformation
McapFeatureOverlapsTrans <- data.frame(clr(t(McapFeatureOverlapsPercents[,seq(5, 37, 4)] / 100))) #Use centered log-ratio transformation on proportion data
tail(McapFeatureOverlapsTrans) # Confirm transformation
McapCpGPercentsTrans <- data.frame(clr(McapCpGTypePercents / 100)) #Use centered log-ratio transformation on proportion data
tail(McapCpGPercentsTrans) # Confirm transformation
dissimMcapFeatureOverlapsTrans <- vegdist(McapFeatureOverlapsTrans, "euclidean") #Calculate euclidean dissimilarity matrix
McapFeatureOverlapsPCoA <- cmdscale(dissimMcapFeatureOverlapsTrans, eig = TRUE, add = TRUE) #Perform the PCoA. Include eigenvalues for each PC, and add a constant so default eigenvalues are non-negative.
McapFeatureOverlapsPCoA$points #View PC scores
McapFeatureOverlapsPCoA$eig #View eigenvalues
(McapFeatureOverlapsPCoA$eig / sum(McapFeatureOverlapsPCoA$eig)) * 100 #Calculate percent variation explained by each PC
plot(McapFeatureOverlapsPCoA$eig/sum(McapFeatureOverlapsPCoA$eig)*100,
type = "b",lwd = 2,col = "blue",
xlab = "Principal Component from PCoA", ylab = "% variation explained", main = "% variation explained by PCoA (blue) vs. random expectation (red)") #Plot eigenvalues
lines(bstick(35)*100, type = "b",lwd = 2, col = "red") #Compare eigenvalues to expectations according to the broken stick model
vec.McapFeatureOverlapsPCoA <- envfit(scores(McapFeatureOverlapsPCoA), McapFeatureOverlapsTrans, perm = 1000) #Extract PCs to calculate PC loadings (variable weights)
vec.McapFeatureOverlapsPCoA #Look at statistical results
McapFeatureOverlapsTest <- adonis(dissimMcapFeatureOverlapsTrans ~ sampleInformation) #Conduct perMANOVA by method
McapFeatureOverlapsTest #Look at test output.
disp.McapFeatureOverlapsTrans <- betadisper(dissimMcapFeatureOverlapsTrans, group = sampleInformation, type = 'centroid') #Run a beta dispersion model to assess if significant differences are due to differences in group centroid or variance
anova(disp.McapFeatureOverlapsTrans) #Variance is the same across all groups. Significance in perMANOVA due to centroid differences, not variance
ordiplot(McapFeatureOverlapsPCoA, choices = c(1,2), type = "text", display = "sites", xlab = "PC 1 (92.3%)", ylab = "PC 2 (7.4%)") #Plot basic PCoA
plot(vec.McapFeatureOverlapsPCoA, p.max = 0.05, col = "blue") #Plot loadings that are significant at the 0.05 level
McapFeatureOverlapsWGRR <- vegdist(McapFeatureOverlapsTrans[c(1:3, 4:6),], "euclidean") #Subset WGBS and RRBS data and calculate dissimilarity matrix
McapFeatureOverlapsWGRRTest <- adonis(McapFeatureOverlapsWGRR ~ sampleInformation[1:6]) #Conduct pairwise perMANOVA for WGBS and RRBS data. Only use sequencing method metadata for these samples
McapFeatureOverlapsWGRRTest
McapFeatureOverlapsWGMB <- vegdist(McapFeatureOverlapsTrans[c(1:3, 7:9),], "euclidean") #Subset WGBS and MBD-BS data and calculate dissimilarity matrix
McapFeatureOverlapsWGMBTest <- adonis(McapFeatureOverlapsWGMB ~ sampleInformation[c(1:3, 7:9)]) #Conduct pairwise perMANOVA for WGBS and MBD-BS data. Only use sequencing method metadata for these samples
McapFeatureOverlapsWGMBTest
McapFeatureOverlapsRRMB <- vegdist(McapFeatureOverlapsTrans[c(4:9),], "euclidean") #Subset RRBS and MBD-BS data and calculate dissimilarity matrix
McapFeatureOverlapsRRMBTest <- adonis(McapFeatureOverlapsRRMB ~ sampleInformation[c(4:9)]) #Conduct pairwise perMANOVA for WGBS and RRBS data. Only use sequencing method metadata for these samples
McapFeatureOverlapsRRMBTest
McapFeatureOverlapsGLMData <- cbind("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(seq(1:3), times = 3),
data.frame(t(McapFeatureOverlapsPercents[,seq(5, 37, 4)] / 100))) #Create master dataframe for GLM
head(McapFeatureOverlapsGLMData) #Confirm dataframe creation
McapCDSModel <- glmmTMB(CDS ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapFeatureOverlapsGLMData) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapCDSModel) #Look at model output
McapIntronsModel <- glmmTMB(Introns ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapFeatureOverlapsGLMData) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapIntronsModel) #Look at model output
McapUpstreamFlanksModel <- glmmTMB(Upstream.Flanks ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapFeatureOverlapsGLMData) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapUpstreamFlanksModel) #Look at model output
McapUpstreamFlanksModel <- glmmTMB(Upstream.Flanks ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapFeatureOverlapsGLMData) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapUpstreamFlanksModel) #Look at model output
McapDownstreamFlanksModel <- glmmTMB(Downstream.Flanks ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapFeatureOverlapsGLMData) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapDownstreamFlanksModel) #Look at model output
McapIntergenicModel <- glmmTMB(Intergenic ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = McapFeatureOverlapsGLMData) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(McapIntergenicModel) #Look at model output
PactFeatureOverlapsTrans <- data.frame(clr(t(PactFeatureOverlapsPercents[,seq(5, 37, 4)] / 100))) #Use centered log-ratio transformation on proportion data
tail(PactFeatureOverlapsTrans) # Confirm transformation
dissimPactFeatureOverlapsTrans <- vegdist(PactFeatureOverlapsTrans, "euclidean") #Calculate euclidean dissimilarity matrix
PactFeatureOverlapsPCoA <- cmdscale(dissimPactFeatureOverlapsTrans, eig = TRUE, add = TRUE) #Perform the PCoA. Include eigenvalues for each PC, and add a constant so default eigenvalues are non-negative.
PactFeatureOverlapsPCoA$points #View PC scores
PactFeatureOverlapsPCoA$eig #View eigenvalues
(PactFeatureOverlapsPCoA$eig / sum(PactFeatureOverlapsPCoA$eig)) * 100 #Calculate percent variation explained by each PC
plot(PactFeatureOverlapsPCoA$eig/sum(PactFeatureOverlapsPCoA$eig)*100,
type = "b",lwd = 2,col = "blue",
xlab = "Principal Component from PCoA", ylab = "% variation explained", main = "% variation explained by PCoA (blue) vs. random expectation (red)") #Plot eigenvalues
lines(bstick(35)*100, type = "b",lwd = 2, col = "red") #Compare eigenvalues to expectations according to the broken stick model
vec.PactFeatureOverlapsPCoA <- envfit(scores(PactFeatureOverlapsPCoA), PactFeatureOverlapsTrans, perm = 1000) #Extract PCs to calculate PC loadings (variable weights)
vec.PactFeatureOverlapsPCoA #Look at statistical results
PactFeatureOverlapsTest <- adonis(dissimPactFeatureOverlapsTrans ~ sampleInformation) #Conduct perMANOVA by method
PactFeatureOverlapsTest #Look at test output.
disp.PactFeatureOverlapsTrans <- betadisper(dissimPactFeatureOverlapsTrans, group = sampleInformation, type = 'centroid') #Run a beta dispersion model to assess if significant differences are due to differences in group centroid or variance
anova(disp.PactFeatureOverlapsTrans) #Variance is the same between groups. Significance in perMANOVA due to centroid differences, not variance
ordiplot(PactFeatureOverlapsPCoA, choices = c(1,2), type = "text", display = "sites", xlab = "PC 1 (82.5%)", ylab = "PC 2 (15.0%)") #Plot basic PCoA
plot(vec.PactFeatureOverlapsPCoA, p.max = 0.05, col = "blue") #Plot loadings that are significant at the 0.05 level
PactFeatureOverlapsWGRR <- vegdist(PactFeatureOverlapsTrans[c(1:3, 4:6),], "euclidean") #Subset WGBS and RRBS data and calculate dissimilarity matrix
PactFeatureOverlapsWGRRTest <- adonis(PactFeatureOverlapsWGRR ~ sampleInformation[1:6]) #Conduct pairwise perMANOVA for WGBS and RRBS data. Only use sequencing method metadata for these samples
PactFeatureOverlapsWGRRTest
disp.PactFeatureOverlapsWGRR <- betadisper(PactFeatureOverlapsWGRR, group = sampleInformation[1:6], type = 'centroid') #Run a beta dispersion model to assess if differences are due to differences in group centroid or variance
anova(disp.PactFeatureOverlapsWGRR) #Variance is the same between groups.
PactFeatureOverlapsWGMB <- vegdist(PactFeatureOverlapsTrans[c(1:3, 7:9),], "euclidean") #Subset WGBS and MBD-BS data and calculate dissimilarity matrix
PactFeatureOverlapsWGMBTest <- adonis(PactFeatureOverlapsWGMB ~ sampleInformation[c(1:3, 7:9)]) #Conduct pairwise perMANOVA for WGBS and MBD-BS data. Only use sequencing method metadata for these samples
PactFeatureOverlapsWGMBTest
disp.PactFeatureOverlapsWGMB <- betadisper(PactFeatureOverlapsWGMB, group = sampleInformation[c(1:3, 7:9)], type = 'centroid') #Run a beta dispersion model to assess if differences are due to differences in group centroid or variance
anova(disp.PactFeatureOverlapsWGMB) #Variance is the same between groups.
PactFeatureOverlapsRRMB <- vegdist(PactFeatureOverlapsTrans[c(4:9),], "euclidean") #Subset RRBS and MBD-BS data and calculate dissimilarity matrix
PactFeatureOverlapsRRMBTest <- adonis(PactFeatureOverlapsRRMB ~ sampleInformation[c(4:9)]) #Conduct pairwise perMANOVA for WGBS and RRBS data. Only use sequencing method metadata for these samples
PactFeatureOverlapsRRMBTest
disp.PactFeatureOverlapsRRMB <- betadisper(PactFeatureOverlapsRRMB, group = sampleInformation[c(4:9)], type = 'centroid') #Run a beta dispersion model to assess if differences are due to differences in group centroid or variance
anova(disp.PactFeatureOverlapsRRMB) #Variance is different between groups.
PactFeatureOverlapsGLMData <- cbind("seqMethod" = c(rep("A", times = 3), rep("B", times = 3), rep("C", times = 3)),
"replicate" = rep(seq(1:3), times = 3),
data.frame(t(PactFeatureOverlapsPercents[,seq(5, 37, 4)] / 100))) #Create master dataframe for GLM
head(PactFeatureOverlapsGLMData) #Confirm dataframe creation
PactCDSModel <- glmmTMB(CDS ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = PactFeatureOverlapsGLMData) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(PactCDSModel) #Look at model output.
PactIntronsModel <- glmmTMB(Introns ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = PactFeatureOverlapsGLMData) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(PactIntronsModel) #Look at model output.
PactUpstreamFlanksModel <- glmmTMB(Upstream.Flanks ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = PactFeatureOverlapsGLMData) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(PactUpstreamFlanksModel) #Look at model output
PactDownstreamFlanksModel <- glmmTMB(Downstream.Flanks ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = PactFeatureOverlapsGLMData) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(PactDownstreamFlanksModel) #Look at model output
PactIntergenicModel <- glmmTMB(Intergenic ~ seqMethod + (1|replicate),
family = beta_family(link = "logit"),
data = PactFeatureOverlapsGLMData) #Run the model using a beta distribution and a logit link. Use replicate as a random effect
summary(PactIntergenicModel) #Look at model output
tail(McapFeatureOverlaps) #Check summary table
head(McapFeatureOverlapsPercents) #Check calculations
McapFeatureOverlapsPercents[,seq(5, 37, 4)]
summary(McapCpGLowModel)[1]
summary(McapCpGLowModel)[2]
summary(McapCpGLowModel)[3]
summary(McapCpGLowModel)[4]
summary(McapCpGLowModel)[5]
summary(McapCpGLowModel)[6]
summary(McapCpGLowModel)$coefficients$cond
summary(McapCpGLowModel)$coefficients$cond[1]
summary(McapCpGLowModel)$coefficients$cond[4]
summary(McapCpGLowModel)$coefficients$cond[10]
summary(McapCpGLowModel)$coefficients$cond[10:12]
McapCpGMethStatusStatOutput <- data.frame("coefficient" = rep(c("seqMethodB", "seqMethodC"), times = 3),
"z.value" = c(summary(McapCpGHighModel)$coefficients$cond[8:9], summary(McapCpGLModModel)$coefficients$cond[8:9], summary(McapCpGLowModel)$coefficients$cond[8:9]),
"p.value" = c(summary(McapCpGHighModel)$coefficients$cond[11:12], summary(McapCpGLModModel)$coefficients$cond[11:12], summary(McapCpGLowModel)$coefficients$cond[11:12]))
McapCpGMethStatusStatOutput <- data.frame("coefficient" = rep(c("seqMethodB", "seqMethodC"), times = 3),
"z.value" = c(summary(McapCpGHighModel)$coefficients$cond[8:9], summary(McapCpGModModel)$coefficients$cond[8:9], summary(McapCpGLowModel)$coefficients$cond[8:9]),
"p.value" = c(summary(McapCpGHighModel)$coefficients$cond[11:12], summary(McapCpGModModel)$coefficients$cond[11:12], summary(McapCpGLowModel)$coefficients$cond[11:12]))
head(McapCpGMethStatusStatOutput)
McapCpGMethStatusStatOutput$p.adj <- p.adjust(McapCpGMethStatusStatOutput$p.value, method = "fdr") #Correct p-values using FDR
head(McapCpGMethStatusStatOutput) #Confirm changes
write.table(McapCpGMethStatusStatOutput, "../analyses/Characterizing-CpG-Methylation-5x/Mcap/Mcap-CpG-Type-StatResults.txt", quote = FALSE, row.names = FALSE) #Save table
PactCpGMethStatusStatOutput <- data.frame("coefficient" = rep(c("seqMethodB", "seqMethodC"), times = 3),
"z.value" = c(summary(PactCpGHighModel)$coefficients$cond[8:9],
summary(PactCpGModModel)$coefficients$cond[8:9],
summary(PactCpGLowModel)$coefficients$cond[8:9]),
"p.value" = c(summary(PactCpGHighModel)$coefficients$cond[11:12],
summary(PactCpGModModel)$coefficients$cond[11:12],
summary(PactCpGLowModel)$coefficients$cond[11:12])) #Create a dataframe with coefficient, z-value, and p-value information from model summary
head(PactCpGMethStatusStatOutput) #Confirm dataframe creation
PactCpGMethStatusStatOutput$p.adj <- p.adjust(PactCpGMethStatusStatOutput$p.value, method = "fdr") #Correct p-values using FDR
head(PactCpGMethStatusStatOutput) #Confirm changes
write.table(PactCpGMethStatusStatOutput, "../analyses/Characterizing-CpG-Methylation-5x/Pact/Pact-CpG-Type-StatResults.txt", quote = FALSE, row.names = FALSE) #Save table
McapCpGFeatureOverlapStatOutput <- data.frame("coefficient" = rep(c("seqMethodB", "seqMethodC"), times = 5),
"z.value" = c(summary(McapCDSModel)$coefficients$cond[8:9],
summary(McapIntronsModel)$coefficients$cond[8:9],
summary(McapUpstreamFlanksModel)$coefficients$cond[8:9],
summary(McapDowntreamFlanksModel)$coefficients$cond[8:9],
summary(McapIntergenicModel)$coefficients$cond[8:9]),
"p.value" = c(summary(McapCDSModel)$coefficients$cond[11:12],
summary(McapIntronsModel)$coefficients$cond[11:12],
summary(McapUpstreamFlanksModel)$coefficients$cond[11:12],
summary(McapDowntreamFlanksModel)$coefficients$cond[11:12],
summary(McapIntergenicModel)$coefficients$cond[11:12])) #Create a dataframe with coefficient, z-value, and p-value information from model summary
McapCpGFeatureOverlapStatOutput <- data.frame("coefficient" = rep(c("seqMethodB", "seqMethodC"), times = 5),
"z.value" = c(summary(McapCDSModel)$coefficients$cond[8:9],
summary(McapIntronsModel)$coefficients$cond[8:9],
summary(McapUpstreamFlanksModel)$coefficients$cond[8:9],
summary(McapDownstreamFlanksModel)$coefficients$cond[8:9],
summary(McapIntergenicModel)$coefficients$cond[8:9]),
"p.value" = c(summary(McapCDSModel)$coefficients$cond[11:12],
summary(McapIntronsModel)$coefficients$cond[11:12],
summary(McapUpstreamFlanksModel)$coefficients$cond[11:12],
summary(McapDownstreamFlanksModel)$coefficients$cond[11:12],
summary(McapIntergenicModel)$coefficients$cond[11:12])) #Create a dataframe with coefficient, z-value, and p-value information from model summary
head(McapCpGFeatureOverlapStatOutput) #Confirm dataframe creation
McapCpGFeatureOverlapStatOutput$p.adj <- p.adjust(McapCpGFeatureOverlapStatOutput$p.value, method = "fdr") #Correct p-values using FDR
head(McapCpGFeatureOverlapStatOutput) #Confirm changes
McapCpGFeatureOverlapStatOutput$p.adj <- p.adjust(McapCpGFeatureOverlapStatOutput$p.value, method = "fdr") #Correct p-values using FDR
head(McapCpGFeatureOverlapStatOutput) #Confirm changes
write.table(McapCpGFeatureOverlapStatOutput, "../analyses/Characterizing-CpG-Methylation-5x/Mcap/Mcap-CpG-Overlap-StatResults.txt", quote = FALSE, row.names = FALSE) #Save table
PactCpGFeatureOverlapStatOutput <- data.frame("coefficient" = rep(c("seqMethodB", "seqMethodC"), times = 5),
"z.value" = c(summary(PactCDSModel)$coefficients$cond[8:9],
summary(PactIntronsModel)$coefficients$cond[8:9],
summary(PactUpstreamFlanksModel)$coefficients$cond[8:9],
summary(PactDownstreamFlanksModel)$coefficients$cond[8:9],
summary(PactIntergenicModel)$coefficients$cond[8:9]),
"p.value" = c(summary(PactCDSModel)$coefficients$cond[11:12],
summary(PactIntronsModel)$coefficients$cond[11:12],
summary(PactUpstreamFlanksModel)$coefficients$cond[11:12],
summary(PactDownstreamFlanksModel)$coefficients$cond[11:12],
summary(PactIntergenicModel)$coefficients$cond[11:12])) #Create a dataframe with coefficient, z-value, and p-value information from model summary
head(PactCpGFeatureOverlapStatOutput) #Confirm dataframe creation
PactCpGFeatureOverlapStatOutput$p.adj <- p.adjust(PactCpGFeatureOverlapStatOutput$p.value, method = "fdr") #Correct p-values using FDR
head(PactCpGFeatureOverlapStatOutput) #Confirm changes
write.table(PactCpGFeatureOverlapStatOutput, "../analyses/Characterizing-CpG-Methylation-5x/Pact/Pact-CpG-Overlap-StatResults.txt", quote = FALSE, row.names = FALSE) #Save table
